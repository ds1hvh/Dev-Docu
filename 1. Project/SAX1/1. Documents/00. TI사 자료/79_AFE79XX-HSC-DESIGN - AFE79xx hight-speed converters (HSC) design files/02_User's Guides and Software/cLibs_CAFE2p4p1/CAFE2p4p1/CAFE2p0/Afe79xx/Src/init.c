
/** @file dsaAndNco.c
 * 	@brief	This file has DSA and NCO related functions. <br>
 * 		<b> Version 2.3:</b> <br>
 *      Moved these functions from baseFunc.c
*/

#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "afe79xxLog.h"
#include "afe79xxTypes.h"

#include "afeCommonMacros.h"

#include "baseFunc.h"
#include "basicFunctions.h"
#include "afeParameters.h"
#include "hMacro.h"

/**
    @brief Bringup function configuration function from log file for format 0 of Latte log.
    @details Bringup function configuration function from log file for format 0 of Latte log. This function needs to be changed if the input to the function is not as file path.
    @param afeId AFE ID
    @param file Log File Path as generated by Latte.
    @param breakAtPollFail If this is 0, then configuration will continue when some poll fails. If it is 1, configuration will stop when some poll fails. 
    @param breakAtReadCheckFail If this is 0, then configuration will continue when some SPI Read Check fails. If it is 1, configuration will stop when some SPI Read Checks fails. 
    @return Returns if AFE initialization passed or failed.
*/
int8_t configAfeFromFileFormat0(uint8_t afeId, char *file, uint8_t breakAtPollFail, uint8_t breakAtReadCheckFail)
{
    uint8_t errorStatus = 0;
    AFE_PARAMS_VALID(file != NULL);

    FILE *fp = fopen(file, "r");
    if (NULL == fp)
    {
        printf("File open error.\n");
        return RET_EXEC_FAIL;
    }
    uint8_t returnVal = 0;
    char strLine[256] = {0};
    char op[16] = {0};
    int32_t temp2, temp3, temp4;
    uint32_t utemp1, utemp2, utemp4;
    uint16_t spiaddr = 0;
    uint8_t spidata = 0;
    uint8_t spiCheckSuccess = 0;
    uint8_t lsb, msb;
    float delay;

    while (!feof(fp))
    {
        memset(strLine, 0, sizeof(strLine));
        fgets(strLine, 256, fp);

        int8_t ret = sscanf(strLine, "%15[^ ] %x,%x,%d,%d", op, &utemp1, &utemp2, &temp3, &temp4);
        spiaddr = (uint16_t)utemp1;
        lsb = (uint8_t)temp3;
        msb = (uint8_t)temp4;
        spidata = (uint8_t)utemp2;
        if (5 == ret && 0 == strcasecmp(op, "spiwrite"))
        {
            afeLogDbg("AFE FROM FILE WRITE: 0x%04x[%d:%d] = 0x%02x \n", spiaddr, lsb, msb, spidata);
            AFE_FUNC_EXEC(afeSpiWriteWrapper(afeId, spiaddr, spidata, lsb, msb));
            continue;
        }
        else if (4 == ret && 0 == strcasecmp(op, "spiread"))
        {
            AFE_FUNC_EXEC(afeSpiReadWrapper(afeId, spiaddr, lsb, msb, &spidata));
            afeLogDbg("AFE FROM FILE READ: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
            continue;
        }

        ret = sscanf(strLine, "%15[^ ] %x,%d,%d,%x", op, &utemp1, &temp2, &temp3, &utemp4);
        spiaddr = (uint16_t)utemp1;
        lsb = (uint8_t)temp2;
        msb = (uint8_t)temp3;
        spidata = (uint8_t)utemp4;

        if (5 == ret && 0 == strcasecmp(op, "spipoll"))
        {
            returnVal = afeSpiPollLogWrapper(afeId, spiaddr, lsb, msb, spidata);
            if (returnVal == RET_OK)
            {
                afeLogDbg("AFE FROM FILE POLL Success: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
            }
            else
            {
                afeLogErr("AFE FROM FILE POLL Failed: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                errorStatus |= 1;
                if (breakAtPollFail)
                    return RET_EXEC_FAIL;
            }
            continue;
        }
        else if (5 == ret && 0 == strcasecmp(op, "SPIReadCheck"))
        {
            AFE_FUNC_EXEC(afeSpiCheckWrapper(afeId, spiaddr, lsb, msb, spidata, &spiCheckSuccess));
            if (spiCheckSuccess == 0)
                afeLogDbg("AFE FROM FILE Read Check Success: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
            else
            {
                afeLogErr("AFE FROM FILE Read Check Fail: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                errorStatus |= 1;
                if (breakAtReadCheckFail)
                    return RET_EXEC_FAIL;
            }
            continue;
        }
        ret = sscanf(strLine, "%15[^ ] %f", op, &delay);
        if (2 == ret)
        {
            waitMs((uint32_t)(delay * 1000));
            afeLogDbg("AFE FROM FILE WAIT: %d ms\n", delay);
            continue;
        }

        char tempStr[16] = {0};
        int8_t ret2 = sscanf(strLine, "%10[^ ]: ", tempStr);
        if (ret2 == 1 && (strcasecmp(tempStr, "//START:") || strcasecmp(tempStr, "//END:")))
            afeLogSpiLog("%s", strLine);
    }
    fclose(fp);
    if (errorStatus)
        return RET_EXEC_FAIL;
    else
        return RET_OK;
}

/**
    @brief Bringup function configuration function from log file for format 5 of Latte log.
    @details Bringup function configuration function from log file for format 5 of Latte log. This function needs to be changed if the input to the function is not as file path.
    @param afeId AFE ID
    @param file Log File Path as generated by Latte.
    @param breakAtPollFail If this is 0, then configuration will continue when some poll fails. If it is 1, configuration will stop when some poll fails. 
    @param breakAtReadCheckFail If this is 0, then configuration will continue when some SPI Read Check fails. If it is 1, configuration will stop when some SPI Read Checks fails. 
    @return Returns if AFE initialization passed or failed.
*/
int8_t configAfeFromFileFormat5(uint8_t afeId, char *file, uint8_t breakAtPollFail, uint8_t breakAtReadCheckFail)
{
    uint8_t errorStatus = 0;
    AFE_PARAMS_VALID(file != NULL);

    FILE *fp = fopen(file, "r");
    if (NULL == fp)
    {
        printf("File open error.\n");
        return RET_EXEC_FAIL;
    }
    uint8_t returnVal = 0;
    char strLine[256] = {0};
    int32_t temp4, temp5;
    uint32_t temp1, temp2, temp3;
    uint16_t spiaddr = 0;
    uint8_t spidata = 0;
    uint8_t spiCheckSuccess = 0;
    uint8_t lsb, msb;
    char tempStr[16] = {0};
    while (!feof(fp))
    {
        memset(strLine, 0, sizeof(strLine));
        fgets(strLine, 256, fp);

        int8_t ret = sscanf(strLine, "{0x%x,0x%x,0x%x,%d,%d}", &temp1, &temp2, &temp3, &temp4, &temp5);
        spiaddr = (uint16_t)temp2;
        spidata = (uint8_t)temp3;
        lsb = (uint8_t)temp4;
        msb = (uint8_t)temp5;
        if (5 == ret)
        {
            if (temp1 == 0)
            {
                AFE_FUNC_EXEC(afeSpiReadWrapper(afeId, spiaddr, lsb, msb, &spidata));
                afeLogDbg("AFE FROM FILE READ: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                continue;
            }
            else if (temp1 == 1)
            {
                AFE_FUNC_EXEC(afeSpiWriteWrapper(afeId, spiaddr, spidata, lsb, msb));
                afeLogDbg("AFE FROM FILE WRITE: 0x%04x[%d:%d] = 0x%02x \n", spiaddr, lsb, msb, spidata);
                continue;
            }
            else if (temp1 == 2)
            {
                AFE_FUNC_EXEC(afeSpiCheckWrapper(afeId, spiaddr, lsb, msb, spidata, &spiCheckSuccess));
                if (spiCheckSuccess == 0)
                    afeLogDbg("AFE FROM FILE Read Check Success: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                else
                {
                    afeLogErr("AFE FROM FILE Read Check Fail: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                    errorStatus |= 1;
                    if (breakAtReadCheckFail)
                        return RET_EXEC_FAIL;
                }
                continue;
            }
            else if (temp1 == 3)
            {
                returnVal = afeSpiPollLogWrapper(afeId, spiaddr, lsb, msb, spidata);
                if (returnVal == RET_OK)
                {
                    afeLogDbg("AFE FROM FILE POLL Success: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                }
                else
                {
                    afeLogErr("AFE FROM FILE POLL Failed: 0x%04x[%d:%d] = 0x%04x\n", spiaddr, lsb, msb, spidata);
                    errorStatus |= 1;
                    if (breakAtPollFail)
                        return RET_EXEC_FAIL;
                }
                continue;
            }
            else if (temp1 == 5)
            {
                waitMs((uint32_t)(temp2));
                afeLogDbg("AFE FROM FILE WAIT: %d ms\n", temp2);
                continue;
            }
        }
        else
        {
            int8_t ret = sscanf(strLine, "%10[^ ]: ", tempStr);
            if (ret == 1 && (strcasecmp(tempStr, "//START:") || strcasecmp(tempStr, "//END:")))
                afeLogDbg("%s", strLine);
        }
    }
    fclose(fp);

    if (errorStatus)
        return RET_EXEC_FAIL;
    else
        return RET_OK;
}

/**
    @brief Common Bringup function configuration function.
    @details Common Bringup function configuration function from log file. This function needs to be changed if the input to the function is not as file path.
    @param afeId AFE ID
    @param logFormat Choose the format between 0 and 5.
    @param file Log File Path as generated by Latte.
    @param breakAtPollFail If this is 0, then configuration will continue when some poll fails. If it is 1, configuration will stop when some poll fails. 
    @param breakAtReadCheckFail If this is 0, then configuration will continue when some SPI Read Check fails. If it is 1, configuration will stop when some SPI Read Checks fails. 
    @return Returns if AFE initialization passed or failed.
*/
int8_t configAfeFromFile(uint8_t afeId, uint8_t logFormat, char *file, uint8_t breakAtPollFail, uint8_t breakAtReadCheckFail)
{
    uint8_t errorStatus = 0;
    if (logFormat == 0)
    {
        return configAfeFromFileFormat0(afeId, file, breakAtPollFail, breakAtReadCheckFail);
    }
    else if (logFormat == 5)
    {
        return configAfeFromFileFormat5(afeId, file, breakAtPollFail, breakAtReadCheckFail);
    }
    else
    {
        afeLogErr("Invalid logFormat: %d", logFormat);
    }
    if (errorStatus)
        return RET_EXEC_FAIL;
    else
        return RET_OK;
}
